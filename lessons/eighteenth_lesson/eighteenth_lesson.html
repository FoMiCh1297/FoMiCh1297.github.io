<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../../style/style_cap.css">
</head>
<body>
    <header >
        <div class="container">
        <div >
            <div class="logo"></div>
                <h1>мое четырнадцатое занятие</h1>
        </div>
        <nav>
            <a href="../../index.html" class="blue">О себе</a>
            <a href="../../My_goals.html" class="blue">Мои цели</a>
            <a href="../lessons.html"class="white">Занятия</a>
            <a href="../../layout/layout.html"class="blue">Макеты</a>
            <a href="https://google.com" target="_blank" class="blue">Google</a>
        </nav>
    </div>
    </header>
    <main >
        <nav>
            <a href="../first_lesson/My_first_lesson.html" class="blue">мое первое занятие</a>
            <a href="../second_lesson/My_second_lesson.html" class="blue">мое второе занятие</a>
            <a href="../third_lesson/My_third_lesson.html" class="blue">мое третье занятие</a>
            <a href="../fourth_lesson/My_fourth_lesson.html" class="blue">мое четвертое занятие</a>
            <a href="../fifth_lesson/My_fifth_lesson.html" class="blue">мое пятое занятие</a>
            <a href="../sixth_lesson/sixth_lesson.html" class="blue">мое шестое занятие</a>
        <a href="../seventh_lesson/seventh_lesson.html" class="blue">мое седьмое занятие</a>
        <a href="../eighth_lesson/eighth_lesson.html" class="blue">мое восьмое занятие</a>
        <a href="../ninth_lesson/ninth_lesson.html" class="blue">мое девятое занятие</a>
        <a href="../tenth_lesson/tenth_lesson.html" class="blue">мое десятое занятие</a>
        <a href="../eleventh_lesson/eleventh_lesson.html" class="blue">мое одиннадцатое занятие</a>
        <a href="../twelfth lesson/twelfth_lesson.html" class="blue">мое двенадцатое занятие</a>
        <a href="../thirteenth_lesson/thirteenth_lesson.html" class="blue">мое тринадцатое занятие</a>
        <a href="../fourteenth_lesson/fourteenth lesson.html" class="blue">мое четырнадцатое занятие</a>
        <a href="../fifteenth_lesson/fifteenth_lesson.html" class="blue">мое пятнадцатое занятие</a>
        <a href="../sixteenth lesson/sixteenth lesson.html" class="blue">мое шестнадцатое занятие</a>
        <a href="#" class="white">мое восемнадцатое занятие</a>
        <a href="../nineteenth_lesson/nineteenth_lesson.html" class="blue">мое девятнадцатое занятие</a>
        </nav>
        <div class="container2">
        <p><h2>Gulp</h2>— это таск-менеджер для автоматического выполнения часто используемых задач, написанный на языке программирования JavaScript. Программное обеспечение использует командную строку для запуска задач, определённых в файле Gulpfile. Создан как ответвление от проекта Grunt, чтоб взять из него лучшие практики.</p>
        <p><h2>PostCSS</h2>— программа, которая автоматизирует рутинные операции с CSS с помощью расширений, написанных на языке JavaScript. Используется при разработке Википедии, Facebook и GitHub. Один из самых часто загружаемых с npm инструментов для работы с CSS. Разработана Андреем Ситником в компании «Злые марсиане».</p>
      <p> <h2>Быстрый старт</h2>  
        Если вы ранее устанавливали gulp глобально, запустите, npm rm --global gulpпрежде чем следовать этим инструкциям. Для получения дополнительной информации прочтите этот <a href="https://medium.com/gulpjs/gulp-sips-command-line-interface-e53411d4467">Sip</a>.</p>
      <p>
<h2>Проверьте узел, npm и npx </h2> 
node --version
      </p>
      <p>
<h2>Установите утилиту командной строки gulp </h2> 
npm install --global gulp-cli
      </p>
      <p>
<h2>Создайте каталог проекта и перейдите в него </h2> 
npx mkdirp my-project <br>
cd my-project
      </p>
      <p>
<h2>Создайте файл package.json в каталоге вашего проекта </h2> 
npm init
      </p>
      <p>
<h2>Установите пакет gulp в свой devDependencies </h2> 
npm install --save-dev gulp
      </p>
      <p>
<h2>Проверьте свои версии gulp</h2> 
gulp --version
      </p>
      <p>
<h2>Создайте файл gulpfile </h2> 
Используя текстовый редактор, создайте файл с именем gulpfile.js в корне вашего проекта со следующим содержимым: <br>
function defaultTask(cb) { <br>
  // place code for your default task here <br>
  cb(); <br>
} <br>
exports.default = defaultTask <br>
      </p>
      <p>
<h2>Проверить это </h2> 
Запустите команду gulp в каталоге вашего проекта: <br>
gulp <br>
Для выполнения нескольких задач вы можете использовать gulp task othertask.
      </p>
    <p>
      <h2>JavaScript и Gulpfiles</h2>
      Gulp позволяет вам использовать существующие знания JavaScript для написания файлов gulp или использовать ваш опыт работы с gulpfiles для написания простого JavaScript. Хотя для упрощения работы с файловой системой и командной строкой предоставляется несколько утилит, все остальное, что вы пишете, является чистым JavaScript.
    </p>
    <p>
<h2>Gulpfile объяснил</h2>
Gulpfile - это файл в каталоге вашего проекта с названием gulpfile.js(или с заглавной буквы Gulpfile.js, например Makefile), который автоматически загружается при запуске gulpкоманды. В этом файле вы будете часто видеть глоток API, как src(), dest(), series()или , parallel()но любые модули ванили JavaScript или узлов могут быть использованы. Любые экспортированные функции будут зарегистрированы в системе задач gulp.
    </p>
    <p>
      <h2>Транспиляция</h2>
      Вы можете написать gulpfile, используя язык, который требует транспиляции, например TypeScript или Babel, изменив расширение на вашем, gulpfile.jsчтобы указать язык и установить соответствующий модуль транспилятора. 
    <br>  Для TypeScript переименуйте gulpfile.tsи установите модуль ts-node . <br>
Для Babel переименуйте gulpfile.babel.jsи установите модуль @ babel / register . <br>
Большинство новых версий узла поддерживают большинство функций, предоставляемых TypeScript или Babel, за исключением синтаксиса import/ export. Если требуется только этот синтаксис, переименуйте gulpfile.esm.jsи установите модуль esm . <br>
    </p>
    <p>
      <h2>Разделение gulpfile</h2>
      Многие пользователи начинают с добавления всей логики в файл gulp. Если он когда-либо станет слишком большим, его можно будет преобразовать в отдельные файлы.

Каждую задачу можно разделить на отдельный файл, а затем импортировать в gulpfile для композиции. Это не только сохраняет порядок, но и позволяет тестировать каждую задачу независимо или изменять композицию в зависимости от условий.

Разрешение модуля узла позволяет вам заменить ваш gulpfile.jsфайл каталогом с именем gulpfile.js, содержащим index.jsфайл, который обрабатывается как gulpfile.js. Затем этот каталог может содержать ваши отдельные модули для задач. Если вы используете транспилятор, назовите папку и файл соответствующим образом.
    </p>
    <p>
<h2>Создание задач</h2>
Каждая задача gulp - это асинхронная функция JavaScript - функция, которая принимает обратный вызов при первой ошибке или возвращает поток, обещание, эмиттер событий, дочерний процесс или наблюдаемое ( подробнее об этом позже ). Из-за некоторых ограничений платформы синхронные задачи не поддерживаются, хотя есть неплохая альтернатива .

    </p>
    <p>
      <h2>Экспорт</h2>
      Задачи могут быть общедоступными или частными . <br>

Общедоступные задачи экспортируются из вашего gulpfile, что позволяет запускать их с помощью gulpкоманды. <br>
Частные задачи предназначены для внутреннего использования, обычно как часть series()или parallel()композиция.
    </p>
    <p>
<h2>Составьте задачи</h2>
Gulp предоставляет два мощных метода композиции series()и parallel(), позволяя объединять отдельные задачи в более крупные операции. Оба метода принимают любое количество функций задач или составных операций. series()и parallel()могут быть вложены внутрь себя или друг в друга на любую глубину.
    </p>
    <p>
<h2>Асинхронное завершение</h2>
Библиотеки узлов обрабатывают асинхронность различными способами. Наиболее распространенным шаблоном являются обратные вызовы при первой ошибке , но вы также можете встретить потоки , обещания , эмиттеры событий , дочерние процессы или наблюдаемые объекты . Задачи Gulp нормализуют все эти типы асинхронности.
    </p>
    <p>
<h2>Работа с файлами</h2>
src()И dest()метода разоблачена глотком взаимодействовать с файлами на вашем компьютере. <br>

src()дается глобус для чтения из файловой системы и создает поток узла . Он находит все совпадающие файлы и считывает их в память для прохождения через поток. <br>

Поток, созданный с помощью, src()должен быть возвращен из задачи, чтобы сигнализировать об асинхронном завершении, как указано в разделе «Создание задач» . <br>
Основной API потока - это .pipe()метод объединения потоков Transform или Writable. <br>
dest()дается строка каталога вывода, а также создается поток Node, который обычно используется в качестве потока-ограничителя. Когда он получает файл, прошедший через конвейер, он записывает содержимое и другие детали в файловую систему в заданном каталоге. symlink()Метод также доступен и работает как dest(), но создает ссылки вместо файлов (см symlink()для более подробной информации). <br>
Чаще всего плагины размещаются между методами src()и dest()используют их .pipe()и преобразуют файлы в потоке.
</p>
    <p>
<h2>Добавление файлов в поток</h2>
src()также может быть размещен в середине конвейера для добавления файлов в поток на основе заданных глобусов. Дополнительные файлы будут доступны только для преобразований позже в потоке. Если глобусы перекрываются , файлы будут добавлены снова. <br>
Это может быть полезно для транспиляции некоторых файлов перед добавлением простых файлов JavaScript в конвейер и отменой всего.
    </p>
    <p>
<h2>Выход по фазам</h2>
dest()может использоваться в середине конвейера для записи промежуточных состояний в файловую систему. Когда файл получен, текущее состояние записывается в файловую систему, путь обновляется для представления нового местоположения выходного файла, а затем этот файл продолжается по конвейеру.
<br>
Эта функция может быть полезна для создания неминифицированных и минифицированных файлов с помощью одного и того же конвейера.
    </p>
    <p>
      <h2>Режимы: потоковый, с буферизацией и пустой</h2>
      src()может работать в трех режимах: буферизация, потоковая передача и пустой. Они настраиваются с bufferи read опции на src().
<br>
По умолчанию используется режим буферизации, который загружает содержимое файла в память. Плагины обычно работают в режиме буферизации, и многие из них не поддерживают режим потоковой передачи. <br>
Режим потоковой передачи существует в основном для работы с большими файлами, которые не помещаются в памяти, такими как гигантские изображения или фильмы. Содержимое передается из файловой системы небольшими порциями, а не загружается сразу. Если вам нужно использовать потоковый режим, поищите плагин, который его поддерживает, или напишите свой собственный. <br>
Пустой режим не содержит содержимого и полезен при работе только с метаданными файла.
    </p>
    <p>
      <h2>Рекомендации по плагину PostCSS</h2>
      Плагин PostCSS - это функция, которая получает и обычно преобразует AST CSS от анализатора PostCSS.
    </p>
    <p>
<h2>API</h2>
<h3>Очистить имя с postcss-префиксом</h3>
Назначение плагина должно быть понятно, просто прочитав его название. Если бы вы написали транспилятор для CSS 4 Custom Media, postcss-custom-media было бы хорошее имя. Если бы вы написали плагин для поддержки миксинов, postcss-mixinsбыло бы хорошее имя.
<br>
Префикс postcss-показывает, что плагин является частью экосистемы PostCSS.
<br>
Это правило не является обязательным для плагинов , которые могут работать в качестве независимых инструментов, без пользователь обязательно зная , что он питается от PostCSS - например, RTLCSS и Autoprefixer .
    </p>
    <p>
<h3>Делай одно и делай это хорошо</h3>
Не создавайте плагины для мультитулов. Несколько небольших одноцелевых плагинов, объединенных в пакет плагинов, обычно являются лучшим решением.
<br>
Например, postcss-preset-envсодержит множество небольших подключаемых модулей, по одному для каждой спецификации W3C. И cssnanoсодержит отдельный плагин для каждой своей оптимизации.
    </p>
    <p>
<h3>Не используйте миксины</h3>
Библиотеки препроцессоров, такие как Compass, предоставляют API с миксинами.
<br>
Плагины PostCSS разные. Плагин не может быть просто набором миксинов для postcss-mixins.
<br>
Для достижения своей цели рассмотрите возможность преобразования действительного CSS или использования настраиваемых правил at и настраиваемых свойств.
    </p>
    <p>
<h3>Хранить postcssвpeerDependencies</h3>
AST может сломаться из-за разной postcssверсии в разных плагинах. Разные плагины могут использовать разных создателей узлов (например, postcss.decl()).
    </p>
    <p>
      <h3>Установить plugin.postcssPluginс именем плагина</h3>
      Имя плагина будет использоваться в сообщениях об ошибках и предупреждениях. <br>
      module.exports = opts => { <br>
        return { <br>
          postcssPlugin: 'postcss-name', <br>
          Once (root) { <br>
            // Plugin code <br>
          } <br>
        } <br>
      } <br>
      module.exports.postcss = true <br>
    </p>
    <p>
      <h2>Обработка</h2>
      <h3>Плагин необходимо протестировать</h3>
      CI-сервис, такой как Travis , также рекомендуется для тестирования кода в различных средах. Вы должны протестировать (как минимум) в Node.js активный LTS и текущую стабильную версию.
    </p>
    <p>
<h3>По возможности используйте асинхронные методы</h3>
Например, используйте fs.writeFileвместо fs.writeFileSync
    </p>
    <p>
      <h3> Используйте быстрое сканирование узлов</h3>
      Подписка на конкретный тип узла происходит намного быстрее, чем вызов walk*метода
    </p>
    <p>
<h3>Установить node.sourceдля новых узлов</h3>
Каждый узел должен иметь соответствующий, sourceчтобы PostCSS мог сгенерировать точную исходную карту.
<br>
Поэтому, если вы добавляете новое объявление на основе некоторого существующего объявления, вам следует клонировать существующее объявление, чтобы сохранить оригинал source.
    </p>
    <p>
<h3>Используйте только общедоступный PostCSS API</h3>
Плагины PostCSS не должны полагаться на недокументированные свойства или методы, которые могут быть изменены в любой второстепенной версии. Публичный API описан в документации API .
    </p>
    <p>
<h2>Ошибки</h2>
<h3>Используйте node.errorдля ошибок, относящихся к CSS</h3>
Если у вас есть ошибка из-за входного CSS (например, неизвестное имя в плагине микширования), вы должны использовать node.errorдля создания ошибки, которая включает исходную позицию
    </p>
    <p>
<h3>Используйте result.warnдля предупреждений</h3>
Не печатайте предупреждения с помощью console.logили console.warn, потому что некоторые средства выполнения PostCSS могут не разрешать вывод на консоль.
    </p>
    <p>
<h2>Документация</h2>
<h3>Документируйте свой плагин на английском языке</h3>
Плагины PostCSS должны быть README.mdнаписаны на английском языке. Не бойтесь своего английского, так как сообщество разработчиков ПО исправит ваши ошибки. <br>
Конечно, вы можете писать документацию на других языках; просто назовите их соответствующим образом (например  README.ja.md).
    </p>
    <p>
<h3>Включите примеры ввода и вывода</h3>
Плагин README.mdдолжен содержать пример ввода и вывода CSS. Наглядный пример - лучший способ описать, как работает ваш плагин. <br>
Первый раздел README.md- хорошее место для размещения примеров. См. Пример postcss-opacity .
<br>
Конечно, это правило неприменимо, если ваш плагин не преобразует CSS.
    </p>
    <p>
      <h3>Вести журнал изменений</h3>
      PostCSS плагины должны описать изменения всех своих релизов в отдельном файле, например CHANGELOG.md, History.mdили  GitHub релизы . Посетите Keep A Changelog для получения дополнительной информации о том, как написать один из них.
<br>
Конечно, вы должны использовать SemVer .
    </p>
    <p>
<h3>Включить postcss-pluginключевое слово вpackage.json</h3>
Плагины PostCSS, написанные для npm, должны содержать postcss-pluginключевое слово в своем package.json. Это специальное ключевое слово будет полезно для обратной связи об экосистеме PostCSS. <br>
Для пакетов, не опубликованных в npm, это не обязательно, но рекомендуется, если формат пакета может содержать ключевые слова.
    </p>
      </div>
        </main>
</body>
</html>